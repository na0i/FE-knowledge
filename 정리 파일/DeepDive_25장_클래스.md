## 25장 클래스

#### 클래스는 문법적 설탕

- 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕

- 클래스는 생성자 함수와 매우 유사하게 동작

- 클래스 vs 생성자 함수

  | 클래스                                                                                            | 생성자 함수                                                                                 |
  | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
  | new 연산자 없이 호출할 경우 에러 발생                                                             | new 연산자 없이 호출할 경우 일반 함수로서 호출                                              |
  | 상속을 지원하는 extends와 super 키워드 제공                                                       | extends와 super 키워드 지원 X                                                               |
  | 호이스팅이 발생하지 않는 것처럼 동작                                                              | 함수 선언문으로 정의되면 함수 호이스팅이<br />함수 표현식으로 정의되면 변수 호이스팅이 발생 |
  | 암묵적으로 strict mode가 지정되어 실행                                                            | strict mode 지정되지 않음                                                                   |
  | 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두<br />[[Enumerable]]의 값이 false이다. |                                                                                             |

<br>

#### 클래스 정의

- class 키워드를 사용하여 정의

- 파스칼 케이스를 사용하는 것이 일반적

- ```javascript
  const Person = {};
  ```

- 클래스는 함수다 → 따라서 클래스는 값처럼 사용할 수 있는 일급 객체다.

- 클래스 몸체에서 정의할 수 있는 메서드는 constructor, 프로토타입 메서드, 정적 메서드 세 가지가 있다.

- 클래스와 생성자 함수 정의 방식 비교

  - ![image](https://user-images.githubusercontent.com/77482972/175292043-97af6042-682c-422c-95d2-24e5d611ce0d.png)

<br>

#### 클래스 호이스팅

- 클래스는 함수로 평가된다.
- 클래스 선언문으로 정의한 클래스는 함수 선언문과 동일하게 런타임 이전에 먼저 평가되어 함수 객체를 생성
- 클래스가 평가되어 생성된 함수 객체 = 생성자 함수로서 호출할 수 있는 함수(=constructor)(프로토타입도 더불어 생성)
- 클래스는 클래스 정의 이전에 참조할 수 없다.
  - 클래스 선언문도 변수 선언, 함수 정의와 마찬가지로 호이스팅이 발생
  - 단 let, const 키워드로 선언한 변수처럼 호이스팅(TDZ에 빠진다.)
  - var, let, const, function, class 키워드를 사용하여 선언된 모든 식별자는 호이스팅된다. why? 모든 선언문은 런타임 이전에 실행되기 때문

<br>

#### 인스턴스 생성

- 클래스는 생성자 함수, new 연산자와 함께 호출되어 인스턴스를 생성
- 함수는 new 연산자의 사용 여부에 따라 일반 함수로 호출 / 인스턴스 생성을 위한 생성자 함수로 호출
- 클래스는 인스턴스를 생성하는 것이 유일한 존재 이유이므로 반드시 new 연산자와 함께 호출

<br>

#### 메서드

- 클래스 몸체에는 0개 이상의 메서드만 선언 가능(constructor, 프로토타입 메서드, 정적 메서드)
- **constructor**

  - 인스턴스를 생성하고 초기화하기 위한 특수한 메서드
  - constructor는 이름을 변경할 수 X
  - constructor는 클래스가 평가되어 생성한 함수 객체 코드의 일부
  - 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성
  - constructor과 생성자 함수의 차이

    - constructor는 클래스 내에 최대 한 개만 존재
    - constructor 생략 가능(constructor를 생략한 클래스는 빈 constructor에 의해 빈 객체를 생성)
    - 프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면 constructor 내부에서 this에 인스턴스 프로퍼티를 추가
    - 인스턴스를 생성할 때 클래스 외부에서 인스턴스 프로퍼티의 초기값을 전달하려면 constructor에 매개변수를 선언하고 인스턴스를 생성할 때 초기값을 전달

    ```javascript
    class Person {
      constructor(name, address) {
        this.name = name;
        this.address = address;
      }
    }

    const me = new Person("Lee", "Seoul");
    console.log(me);
    ```

    - constructor는 별도의 반환문을 갖지 않아야 한다.(암묵적으로 this=인스턴스를 반환해야 하기 때문)

- **프로토타입 메서드**
  - 생성자 함수를 사용하여 인스턴스를 생성 & 프로토타입 메서드를 생성하는 경우: 명시적으로 프로토타입에 메서드를 추가(Person.prototype.sayHi 어쩌구)
  - 클래스는 기본적으로 프로토타입 메서드가 된다
  - 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.
  - ![image](https://user-images.githubusercontent.com/77482972/181526531-afc42f98-8dea-4c54-a4af-9dadbbf52029.png)
  - 클래스 몸체에서 정의한 메서드 → 인스턴스의 프로토타입에 존재하는 프로토타입 메서드 → 인스턴스는 프로토타입 메서드를 상속받아 사용 가능
  - 즉, 클래스는 생성자 함수와 같이 인스턴스를 생성하는 생성자 함수
  - **클래스 = 프로토타입 기반의 객체 생성 메커니즘**
- **정적 메서드**
  - 정적 메서드: 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
  - 메서드에 static을 붙이면 정적 메서드가 된다
  - 클래스는 함수 객체로 평가되므로 자신의 프로퍼티/메서드를 소유 가능
  - 정적 메서드는 클래스에 바인딩 된 메서드가 된다
  - 정적 메서드는 클래스 정의 이후 인스턴스를 생성하지 않아도 호출 가능
  - 정적 메서드는 인스턴스로 호출 불가능
- **정적 메서드와 프로토타입 메서드의 차이**

  - 정적 메서드와 프로토타입 메서드는 속해있는 프로토타입 체인이 다름
  - 정적 메서드는 클래스로 호출하고, 프로토타입 메서드는 인스턴스로 호출
  - 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만, 프로토타입 메서드는 가능
  - 메서드 내부에서 인스턴스 프로퍼티를 참조할 필요가 있다면 this를 사용해야하기 때문에 프로토타입 메서드로 정의해야한다.
  - 정적 메서드는 애플리케이션 전역에서 사용할 유틸리피 함수를 ㅓㄴ역함수로 정의하지 않고 메서드로 구조화할 때 유용(예시: Math.max())

  ```javascript
  class Square {
    static area(width, height) {
      return width * height;
    }
  }

  console.log(Square.area(10, 10)); // area의 this는 Square

  class Square {
    constructor(width, height) {
      this.width = width;
      this.height = height;
    }

    area() {
      return this.width * this.height;
    }
  }

  const square = new Square(10, 10);
  console.log(square.area()); // area의 this는 square
  ```

- 클래스에서 정의한 메서드의 특징
  - 메서드 축약표현 사용(function 키워드 생략)
  - 암묵적으로 strict mode로 실행
  - for ... in문이나 Object.keys 문으로 열거 불가능(프로퍼티 어트리뷰트 enumerable의 값이 false)
  - non-constructor이기 때문에 new 연산자와 함께 호출 불가능

---

- 클래스는 평가되어 함수 객체가 된다 → 클래스도 함수 객체 고유의 프로퍼티를 모두 갖고 있다. → 함수와 동일하게 프로토타입과 연결 & 자신의 스코프 체인 구성
- 클래스의 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor 프로퍼티는 클래스 자신을 가리키고 있다 = **클래스가 인스턴스를 생성하는 생성자 함수**
- constructor 내부에서 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 됨
- constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킨다.
- 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체(메서드 이름 앞ㅇ 마침표(.) 연산자 앞에 기술한 객체에 바인딩 된다)
-
